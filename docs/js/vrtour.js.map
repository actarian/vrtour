{"version":3,"names":[],"mappings":"","sources":["src/js/vrtour.js"],"sourcesContent":["/* jshint esversion: 6 */\n/* global window, document, TweenMax, THREE, WEBVR */\n\nimport html2canvas from 'html2canvas';\nimport DragListener from './shared/drag.listener';\nimport { cm, PANEL_RADIUS, POINTER_RADIUS, POINT_RADIUS, ROOM_RADIUS, TEST_ENABLED } from './three/const';\nimport { InteractiveMesh } from './three/interactive.mesh';\nimport { Menu } from './three/menu';\nimport { VR, VR_MODE } from './three/vr';\n\nclass VRTour {\n\n\tconstructor() {\n\t\tthis.mouse = { x: 0, y: 0 };\n\t\tthis.parallax = { x: 0, y: 0 };\n\t\tthis.size = { width: 0, height: 0, aspect: 0 };\n\t\tthis.isUserInteracting = false;\n\t\tthis.longitude = 0;\n\t\tthis.latitude = 0;\n\t\tthis.direction = 1;\n\t\tthis.speed = 1;\n\t\tthis.inertia = new THREE.Vector3();\n\t\tthis.origin = new THREE.Vector3();\n\t\tthis.cameraDirection = new THREE.Vector3();\n\t\tthis.controllerDirection = new THREE.Vector3();\n\t\tthis.init();\n\t}\n\n\tget index() {\n\t\treturn this.index_;\n\t}\n\tset index(index) {\n\t\tthis.index_ = index;\n\t\tthis.view = this.views[index];\n\t}\n\n\tget view() {\n\t\treturn this.view_;\n\t}\n\tset view(view) {\n\t\tthis.onInitView(this.view_, view);\n\t\tthis.view_ = view;\n\t}\n\n\tget hoverPoint() {\n\t\treturn this.hoverPoint_;\n\t}\n\tset hoverPoint(intersection) {\n\t\tconst object = intersection ? intersection.object : null;\n\t\tif (this.hoverPoint_ !== object) {\n\t\t\tthis.hoverPoint_ = object;\n\t\t\tif (object !== null) {\n\t\t\t\tthis.onEnterPanel(object.position.clone());\n\t\t\t} else {\n\t\t\t\tthis.onExitPanel();\n\t\t\t}\n\t\t\tconst tweens = this.points.children.map((x, index) => {\n\t\t\t\tconst from = { scale: x.scale.x };\n\t\t\t\treturn TweenMax.to(from, 0.25, {\n\t\t\t\t\tscale: x === object ? 3 : 1,\n\t\t\t\t\tdelay: 0,\n\t\t\t\t\tonUpdate: () => {\n\t\t\t\t\t\tx.scale.set(from.scale, from.scale, from.scale);\n\t\t\t\t\t},\n\t\t\t\t\tonCompleted: () => {\n\t\t\t\t\t\t// console.log(index, 'completed');\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n\n\tget selectedPoint() {\n\t\treturn this.selectedPoint_;\n\t}\n\tset selectedPoint(intersection) {\n\t\tconst object = intersection && this.isControllerSelecting ? intersection.object : null;\n\t\tif (this.selectedPoint_ !== object) {\n\t\t\tthis.selectedPoint_ = object;\n\t\t\tif (object !== null) {\n\t\t\t\tconst position = object.position;\n\t\t\t\tconst debugInfo = `selectedPoint => {${position.x}, ${position.y}, ${position.z}}`;\n\t\t\t\tthis.debugInfo.innerHTML = debugInfo;\n\t\t\t\t// console.log(this.views.length);\n\t\t\t\tthis.index = (this.index + 1) % this.views.length;\n\t\t\t\t// console.log(index, point, debugInfo);\n\t\t\t}\n\t\t}\n\t}\n\n\tload(jsonUrl) {\n\t\ttry {\n\t\t\tfetch(jsonUrl).then(response => response.json()).then(response => {\n\t\t\t\tthis.views = response.views;\n\t\t\t\tthis.index = 0;\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t}\n\t}\n\n\tinit() {\n\t\tconst body = this.body = document.querySelector('body');\n\t\tconst section = this.section = document.querySelector('.vrtour');\n\t\tconst container = this.container = section.querySelector('.vrtour__container');\n\t\tconst debugInfo = this.debugInfo = section.querySelector('.debug__info');\n\t\tconst debugSave = this.debugSave = section.querySelector('.debug__save');\n\t\t// Dom.detect(body);\n\t\t// body.classList.add('ready');\n\t\tthis.onWindowResize = this.onWindowResize.bind(this);\n\t\tthis.onMouseDown = this.onMouseDown.bind(this);\n\t\tthis.onMouseMove = this.onMouseMove.bind(this);\n\t\tthis.onMouseUp = this.onMouseUp.bind(this);\n\t\tthis.onMouseWheel = this.onMouseWheel.bind(this);\n\t\tthis.onSave = this.onSave.bind(this);\n\t\tthis.onLeftSelectStart = this.onLeftSelectStart.bind(this);\n\t\tthis.onLeftSelectEnd = this.onLeftSelectEnd.bind(this);\n\t\tthis.onRightSelectStart = this.onRightSelectStart.bind(this);\n\t\tthis.onRightSelectEnd = this.onRightSelectEnd.bind(this);\n\t\tthis.initRenderer();\n\t}\n\n\tinitRenderer() {\n\t\tconst scene = this.scene = this.addScene();\n\t\tconst camera = this.camera = this.addCamera();\n\t\tconst pivot = this.pivot = this.addPivot(scene);\n\t\tconst room = this.room = this.addRoom(pivot);\n\t\tconst floor = this.floor = this.addFloor(pivot);\n\t\tconst ceil = this.ceil = this.addCeil(pivot);\n\t\tconst points = this.points = this.addPoints(pivot);\n\t\tconst panel = this.panel = this.addPanel(pivot);\n\t\t// renderer\n\t\tconst renderer = this.renderer = this.addRenderer();\n\t\t// this.container.appendChild(WEBVR.createButton(renderer, { referenceSpaceType: 'local' }));\n\t\tconst vr = this.vr = this.addVR(renderer, this.container);\n\t\t/*\n\t\tconst unsubscribe = vr.addListener('error', (error) => {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t});\n\t\t*/\n\t\t// this.addIO();\n\t\t// unsubscribe();\n\t\t// controllers\n\t\tconsole.log('vr.mode', vr.mode, TEST_ENABLED);\n\t\tif (vr.mode !== VR_MODE.NONE) {\n\t\t\tconst left = this.left = this.addControllerLeft(renderer, scene);\n\t\t\tconst right = this.right = this.addControllerRight(renderer, scene);\n\t\t\tconst menu = this.menu = new Menu(pivot);\n\t\t\tconst text = this.text = this.addText(pivot);\n\t\t\tconst pointer = this.pointer = this.addPointer(pivot);\n\t\t\t// const dragListener = this.dragListener = this.addVRDragListener();\n\t\t\t// hands\n\t\t\t// const hands = this.hands = this.addHands();\n\t\t} else if (TEST_ENABLED) {\n\t\t\tthis.addTestController(scene);\n\t\t\tconst menu = this.menu = new Menu(pivot);\n\t\t\tconst text = this.text = this.addText(pivot);\n\t\t\tcamera.target.z = ROOM_RADIUS;\n\t\t\tcamera.lookAt(camera.target);\n\t\t\tconst dragListener = this.dragListener = this.addDragListener();\n\t\t} else {\n\t\t\tcamera.target.z = ROOM_RADIUS;\n\t\t\tcamera.lookAt(camera.target);\n\t\t\tconst dragListener = this.dragListener = this.addDragListener();\n\t\t}\n\t\t// raycaster\n\t\tconst raycaster = this.raycaster = new THREE.Raycaster();\n\t\twindow.addEventListener('resize', this.onWindowResize, false);\n\t\tdocument.addEventListener('mousemove', this.onMouseMove, false);\n\t\tdocument.addEventListener('wheel', this.onMouseWheel, false);\n\t\tthis.container.addEventListener('mousedown', this.onMouseDown, false);\n\t\tthis.container.addEventListener('mouseup', this.onMouseUp, false);\n\t\tthis.debugSave.addEventListener('click', this.onSave, false);\n\t\tthis.section.classList.add('init');\n\t\tthis.onWindowResize();\n\t}\n\n\taddIO() {\n\t\tconst rr = () => {\n\t\t\treturn -20 + Math.random() * 40;\n\t\t}\n\t\tconst ims = this.ims = new Array(10).fill(null).map(x => {\n\t\t\tconst im = new InteractiveMesh();\n\t\t\tim.position.set(rr(), 0, rr());\n\t\t\tim.on('over', (item) => {\n\t\t\t\titem.material.color.setHex(0xff0000);\n\t\t\t});\n\t\t\tim.on('out', (item) => {\n\t\t\t\titem.material.color.setHex(0xff00ff);\n\t\t\t});\n\t\t\tim.on('down', (item) => {\n\t\t\t\titem.material.color.setHex(0x00ff00);\n\t\t\t});\n\t\t\tim.on('up', (item) => {\n\t\t\t\titem.material.color.setHex(0xff00ff);\n\t\t\t});\n\t\t\tthis.pivot.add(im);\n\t\t\treturn im;\n\t\t});\n\t}\n\n\taddTestController(scene) {\n\t\tconst controller = this.right = new THREE.Group();\n\t\tcontroller.position.set(0, 0, 0);\n\t\tthis.addControllerCylinder(controller, 0);\n\t\tthis.scene.add(controller);\n\t\t// this.controller = controller;\n\t\tconst pointer = this.pointer = this.addPointer(this.pivot);\n\t\tthis.container.addEventListener('mousedown', () => {\n\t\t\tthis.onRightSelectStart();\n\t\t});\n\t\tthis.container.addEventListener('mouseup', () => {\n\t\t\tthis.onRightSelectEnd();\n\t\t});\n\t}\n\n\ttestController() {\n\t\tif (TEST_ENABLED) {\n\t\t\tif (this.controller) {\n\t\t\t\tthis.controller.position.x = this.mouse.x * 50;\n\t\t\t\tthis.controller.position.y = this.mouse.y * 50;\n\t\t\t}\n\t\t\tthis.updateController();\n\t\t}\n\t}\n\n\taddScene() {\n\t\tconst scene = new THREE.Scene();\n\t\t// scene.background = new THREE.Color(0x00000000);\n\t\t// scene.background = new THREE.Color(0x404040);\n\t\t// scene.fog = new THREE.Fog(scene.background, 10, 700);\n\t\treturn scene;\n\t}\n\n\taddCamera() {\n\t\tconst camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, ROOM_RADIUS * 2);\n\t\tcamera.target = new THREE.Vector3();\n\t\treturn camera;\n\t}\n\n\taddText(parent) {\n\t\tconst loader = new THREE.FontLoader();\n\t\tloader.load('fonts/helvetiker_regular.typeface.json', (font) => {\n\t\t\tthis.font = font;\n\t\t\tconst material = new THREE.MeshBasicMaterial({\n\t\t\t\tcolor: 0x33c5f6,\n\t\t\t\ttransparent: true,\n\t\t\t\topacity: 1,\n\t\t\t\tside: THREE.DoubleSide\n\t\t\t});\n\t\t\tthis.fontMaterial = material;\n\t\t\t/*\n\t\t\tconst shapes = font.generateShapes('0', 10);\n\t\t\tconst geometry = new THREE.ShapeBufferGeometry(shapes);\n\t\t\tgeometry.dynamic = true;\n\t\t\tgeometry.computeBoundingBox();\n\t\t\tconst x = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);\n\t\t\tgeometry.translate(x, 5, -80);\n\t\t\t// make shape ( N.B. edge view not visible )\n\t\t\tconst text = new THREE.Mesh(geometry, material);\n\t\t\t// text.position.set(-10000, -10000, -10000);\n\t\t\tthis.text = text;\n\t\t\tparent.add(text);\n\t\t\t*/\n\t\t\t/*\n\t\t\t// make line shape ( N.B. edge view remains visible )\n\t\t\tconst matDark = new THREE.LineBasicMaterial({\n\t\t\t\tcolor: color,\n\t\t\t\tside: THREE.DoubleSide\n\t\t\t});\n\t\t\tconst holeShapes = [];\n\t\t\tfor (let i = 0; i < shapes.length; i++) {\n\t\t\t\tconst shape = shapes[i];\n\t\t\t\tif (shape.holes && shape.holes.length > 0) {\n\t\t\t\t\tfor (let j = 0; j < shape.holes.length; j++) {\n\t\t\t\t\t\tconst hole = shape.holes[j];\n\t\t\t\t\t\tholeShapes.push(hole);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tshapes.push.apply(shapes, holeShapes);\n\t\t\tconst lineText = new THREE.Object3D();\n\t\t\tfor (let i = 0; i < shapes.length; i++) {\n\t\t\t\tconst shape = shapes[i];\n\t\t\t\tconst points = shape.getPoints();\n\t\t\t\tconst geometry = new THREE.BufferGeometry().setFromPoints(points);\n\t\t\t\tgeometry.translate(xMid, 0, 0);\n\t\t\t\tconst lineMesh = new THREE.Line(geometry, matDark);\n\t\t\t\tlineText.add(lineMesh);\n\t\t\t}\n\t\t\tparent.add(lineText);\n\t\t\t*/\n\t\t});\n\t}\n\n\tsetText(message) {\n\t\tmessage = message || '1';\n\t\tif (this.text) {\n\t\t\tthis.text.parent.remove(this.text);\n\t\t\tthis.text.geometry.dispose();\n\t\t}\n\t\tconst shapes = this.font.generateShapes(message, 5);\n\t\tconst geometry = new THREE.ShapeBufferGeometry(shapes);\n\t\t// geometry.dynamic = true;\n\t\tgeometry.computeBoundingBox();\n\t\tconst x = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);\n\t\tgeometry.translate(x, 0, 0);\n\t\t// make shape ( N.B. edge view not visible )\n\t\tconst text = new THREE.Mesh(geometry, this.fontMaterial);\n\t\ttext.position.set(0, 0, -POINTER_RADIUS);\n\t\tthis.text = text;\n\t\tthis.pivot.add(text);\n\t\t/*\n\t\tconst shapes = this.font.generateShapes(message, 10);\n\t\tconst geometry = new THREE.ShapeBufferGeometry(shapes);\n\t\tgeometry.computeBoundingBox();\n\t\tconst x = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);\n\t\tconst text = this.text;\n\t\ttext.geometry.copy(geometry);\n\t\ttext.geometry.translate(x, 0, 0);\n\t\t// text.geometry.position.needsUpdate = true;\n\t\tgeometry.dispose();\n\t\t*/\n\t}\n\n\tcopyGeometry() {\n\t\tvar MAX_POINTS = 500;\n\n\t\t// geometry\n\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t// attributes\n\t\tvar positions = new Float32Array(MAX_POINTS * 3); // 3 vertices per point\n\t\tgeometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));\n\n\t\t// draw range\n\t\tvar drawCount = 2; // draw the first 2 points, only\n\t\tgeometry.setDrawRange(0, drawCount);\n\n\t\t// material\n\t\tvar material = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 2 });\n\n\t\t// line\n\t\tvar line = new THREE.Line(geometry, material);\n\t\tscene.add(line);\n\t\t// And then to later update after adding new point information:\n\t\tline.geometry.setDrawRange(0, newValue);\n\t}\n\n\taddPivot(parent) {\n\t\tconst group = new THREE.Group();\n\t\tparent.add(group);\n\t\treturn group;\n\t}\n\n\taddRenderer() {\n\t\tconst renderer = new THREE.WebGLRenderer({\n\t\t\tantialias: true,\n\t\t\t// logarithmicDepthBuffer: true,\n\t\t\t// premultipliedAlpha: true,\n\t\t\t// alpha: true,\n\t\t});\n\t\tthis.renderer = renderer;\n\t\t// renderer.shadowMap.enabled = true;\n\t\trenderer.setClearColor(0x000000, 1);\n\t\trenderer.setPixelRatio(window.devicePixelRatio);\n\t\trenderer.setSize(window.innerWidth, window.innerHeight);\n\t\trenderer.vr.enabled = true;\n\t\t// container.innerHTML = '';\n\t\tthis.container.appendChild(renderer.domElement);\n\t\treturn renderer;\n\t}\n\n\taddVR(renderer, container) {\n\t\tconst vr = new VR(renderer, { referenceSpaceType: 'local' }, (error) => {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t});\n\t\tcontainer.appendChild(vr.element);\n\t\treturn vr;\n\t}\n\n\taddRoom(parent) {\n\t\tconst group = new THREE.Group();\n\t\tconst geometry = new THREE.SphereBufferGeometry(ROOM_RADIUS, 72, 72);\n\t\t// const geometry = new THREE.IcosahedronBufferGeometry(ROOM_RADIUS, 4);\n\t\t// console.log(geometry);\n\t\t// invert the geometry on the x-axis so that all of the faces point inward\n\t\tgeometry.scale(-1, 1, 1);\n\t\tconst material = new THREE.MeshBasicMaterial({\n\t\t\tcolor: 0x000000,\n\t\t\tdepthTest: false,\n\t\t\ttransparent: true,\n\t\t\topacity: 0.0,\n\t\t\t// wireframe: true\n\t\t});\n\t\t/*\n\t\tconst material = new THREE.MeshStandardMaterial({\n\t\t\tcolor: '#fefefe',\n\t\t\troughness: 0.9,\n\t\t\tmetalness: 0.1,\n\t\t\troughnessMap: texture,\n\t\t\tmap: texture,\n\t\t\ttransparent: true,\n\t\t\topacity: 0,\n\t\t\t// premultipliedAlpha: true,\n\t\t});\n\t\t*/\n\t\tconst sphere = new THREE.Mesh(geometry, material);\n\t\t// sphere.castShadow = false;\n\t\t// sphere.receiveShadow = true;\n\t\tgroup.renderOrder = -1;\n\t\tgroup.add(sphere);\n\t\tgroup.sphere = sphere;\n\t\t//\n\t\t/*\n\t\tconst rotation = new THREE.Euler(0.0, 0.0, 0.0, 'XYZ');\n\t\tgroup.rotation.set(rotation.x, rotation.y, rotation.z);\n\t\t*/\n\t\tparent.add(group);\n\t\treturn group;\n\t}\n\n\taddFloor(parent) {\n\t\tconst geometry = new THREE.PlaneGeometry(ROOM_RADIUS / 5 * 3, ROOM_RADIUS / 5 * 3, 3, 3);\n\t\tconst loader = new THREE.TextureLoader();\n\t\tconst texture = loader.load('img/floor.jpg');\n\t\tconst textureAlpha = loader.load('img/floor-alpha.jpg');\n\t\tconst material = new THREE.MeshBasicMaterial({\n\t\t\tmap: texture,\n\t\t\talphaMap: textureAlpha,\n\t\t\t// alphaTest: 0.5,\n\t\t\t// blending: THREE.AdditiveBlending,\n\t\t\t// depthTest: true,\n\t\t\ttransparent: true\n\t\t});\n\t\t/*\n\t\tmaterial.blending = THREE.AdditiveBlending;\n\t\t*/\n\t\tconst mesh = new THREE.Mesh(geometry, material);\n\t\tmesh.position.y = -ROOM_RADIUS / 5 * 3;\n\t\tmesh.rotation.x = -Math.PI / 2;\n\t\tparent.add(mesh);\n\t\treturn mesh;\n\t}\n\n\taddCeil(parent) {\n\t\tconst geometry = new THREE.PlaneGeometry(ROOM_RADIUS / 5 * 2, ROOM_RADIUS / 5 * 2, 3, 3);\n\t\tconst loader = new THREE.TextureLoader();\n\t\tconst texture = loader.load('img/ceil.jpg');\n\t\tconst textureAlpha = loader.load('img/ceil-alpha.jpg');\n\t\tconst material = new THREE.MeshBasicMaterial({\n\t\t\tmap: texture,\n\t\t\talphaMap: textureAlpha,\n\t\t\t// alphaTest: 0.5,\n\t\t\t// blending: THREE.AdditiveBlending,\n\t\t\t// depthTest: true,\n\t\t\ttransparent: true\n\t\t});\n\t\tconst mesh = new THREE.Mesh(geometry, material);\n\t\tmesh.position.y = ROOM_RADIUS / 5 * 4;\n\t\tmesh.rotation.x = Math.PI / 2;\n\t\tparent.add(mesh);\n\t\treturn mesh;\n\t}\n\n\taddPointer(parent) {\n\t\t// size 2 about 20 cm radius\n\t\tconst geometry = new THREE.PlaneBufferGeometry(2, 2, 2, 2);\n\t\t// const geometry = new THREE.SphereBufferGeometry(1, 8, 8);\n\t\tconst loader = new THREE.TextureLoader();\n\t\tconst texture = loader.load('img/pin.jpg');\n\t\ttexture.magFilter = THREE.NearestFilter;\n\t\ttexture.wrapT = THREE.RepeatWrapping;\n\t\ttexture.repeat.y = 1;\n\t\t// texture.anisotropy = 0;\n\t\t// texture.magFilter = THREE.LinearMipMapLinearFilter;\n\t\t// texture.minFilter = THREE.NearestFilter;\n\t\tconst material = new THREE.MeshBasicMaterial({\n\t\t\t// color: 0xff0000,\n\t\t\t// map: texture,\n\t\t\talphaMap: texture,\n\t\t\t// alphaTest: 0.5,\n\t\t\t// blending: THREE.AdditiveBlending,\n\t\t\t// depthTest: false,\n\t\t\ttransparent: true,\n\t\t\topacity: 0.5,\n\t\t\t// side: THREE.DoubleSide,\n\t\t});\n\n\t\t/*\n\t\tTHREE.NoBlending\n\t\tTHREE.NormalBlending\n\t\tTHREE.AdditiveBlending\n\t\tTHREE.SubtractiveBlending\n\t\tTHREE.MultiplyBlending\n\t\tTHREE.CustomBlending\n\t\t*/\n\t\t// material.blending = THREE.AdditiveBlending;\n\t\t/*\n        material.blending = THREE.CustomBlending;\n\t\tmaterial.blendEquation = THREE.MaxEquation; //default\n\t\tmaterial.blendSrc = THREE.OneFactor; // THREE.SrcAlphaFactor; //default\n        material.blendDst = THREE.OneFactor; // THREE.OneMinusSrcAlphaFactor; //default\n        */\n\t\tconst mesh = new THREE.Mesh(geometry, material);\n\t\t// mesh.position.x = 100000;\n\t\tmesh.position.set(-100000, -100000, -100000);\n\t\t// mesh.geometry.rotateX(Math.PI);\n\t\t// mesh.lookAt(this.origin);\n\t\t// mesh.lookAt(this.camera.position);\n\t\tparent.add(mesh);\n\t\treturn mesh;\n\t}\n\n\taddPanel(parent) {\n\t\tconst geometry = new THREE.PlaneBufferGeometry(PANEL_RADIUS / 2.5, PANEL_RADIUS / 2.5, 3, 3);\n\t\tconst material = new THREE.MeshBasicMaterial({\n\t\t\ttransparent: true,\n\t\t\topacity: 1,\n\t\t\t// side: THREE.DoubleSide,\n\t\t});\n\t\tconst mesh = new THREE.Mesh(geometry, material);\n\t\tmesh.position.set(100000, 100000, 100000);\n\t\t// parent.add(mesh);\n\t\treturn mesh;\n\t}\n\n\tremovePoints() {\n\t\t/*\n\t\tif (this.points) {\n\t\t\tthis.points.remove();\n\t\t\tdelete this.points;\n\t\t}\n\t\t*/\n\t}\n\n\taddPoints(parent) {\n\t\tconst points = new THREE.Group();\n\t\tparent.add(points);\n\t\treturn points;\n\t}\n\n\taddPoint(parent, position, i) {\n\t\t// console.log('addPoint', parent, position, i);\n\t\t// size 2 about 20 cm radius\n\t\tconst geometry = new THREE.PlaneBufferGeometry(2, 2, 2, 2);\n\t\tconst loader = new THREE.TextureLoader();\n\t\tconst texture = loader.load('img/pin.jpg');\n\t\tconst material = new THREE.MeshBasicMaterial({\n\t\t\talphaMap: texture,\n\t\t\ttransparent: true,\n\t\t\topacity: 0,\n\t\t});\n\t\tconst point = new THREE.Mesh(geometry, material);\n\t\tposition = position.normalize().multiplyScalar(POINT_RADIUS);\n\t\tpoint.position.set(position.x, position.y, position.z);\n\t\tpoint.lookAt(this.origin);\n\t\tparent.add(point);\n\t\tconst from = { opacity: 0 };\n\t\tTweenMax.to(from, 0.5, {\n\t\t\topacity: 1,\n\t\t\tdelay: 0.1 * i,\n\t\t\tonUpdate: () => {\n\t\t\t\t// console.log(index, from.opacity);\n\t\t\t\tpoint.material.opacity = from.opacity;\n\t\t\t\tpoint.material.needsUpdate = true;\n\t\t\t},\n\t\t\tonCompleted: () => {\n\t\t\t\t// console.log(index, 'completed');\n\t\t\t}\n\t\t});\n\t\treturn point;\n\t\t// console.log(index, 'start');\n\t}\n\n\tremovePoint(i) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst point = this.points.children[i];\n\t\t\tconst from = { opacity: 1 };\n\t\t\tTweenMax.to(from, 0.5, {\n\t\t\t\topacity: 0,\n\t\t\t\tdelay: 0.0 * i,\n\t\t\t\tonUpdate: () => {\n\t\t\t\t\t// console.log(index, from.opacity);\n\t\t\t\t\tpoint.material.opacity = from.opacity;\n\t\t\t\t\tpoint.material.needsUpdate = true;\n\t\t\t\t},\n\t\t\t\tonCompleted: () => {\n\t\t\t\t\tthis.points.remove(point);\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tcreatePoint(intersection) {\n\t\tconst position = intersection.point.clone();\n\t\tthis.addPoint(this.points, position, 0);\n\t\tthis.view.points.push({\n\t\t\tid: 2,\n\t\t\tposition: position.toArray(),\n\t\t\ttype: 1,\n\t\t\tname: 'Point 2',\n\t\t\tkey: 'POINT2',\n\t\t});\n\t}\n\n\taddControllerLeft(renderer, parent) {\n\t\tconst controller = renderer.vr.getController(0);\n\t\tconst cylinder = controller.cylinder = this.addControllerCylinder(controller, 0);\n\t\t// controller.addEventListener('selectstart', this.onLeftSelectStart);\n\t\t// controller.addEventListener('selectend', this.onLeftSelectEnd);\n\t\tparent.add(controller);\n\t\treturn controller;\n\t}\n\n\taddControllerRight(renderer, parent) {\n\t\tconst controller = renderer.vr.getController(1);\n\t\tconst cylinder = controller.cylinder = this.addControllerCylinder(controller, 1);\n\t\t/*\n\t\tcontroller.addEventListener('selectstart', this.onRightSelectStart);\n\t\tcontroller.addEventListener('selectend', this.onRightSelectEnd);\n\t\t*/\n\t\tparent.add(controller);\n\t\treturn controller;\n\t}\n\n\taddControllerCylinder(controller, i) {\n\t\tconst geometry = new THREE.CylinderBufferGeometry(cm(2), cm(2), cm(12), 24);\n\t\tconst texture = new THREE.TextureLoader().load('img/matcap.jpg');\n\t\tconst material = new THREE.MeshMatcapMaterial({\n\t\t\tcolor: i === 0 ? 0xff0000 : 0x0000ff,\n\t\t\tmatcap: texture,\n\t\t\ttransparent: true,\n\t\t\topacity: 1,\n\t\t});\n\t\t/*\n\t\tconst material = new THREE.MeshBasicMaterial({\n\t\t\tcolor: i === 0 ? 0x0000ff : 0xff0000,\n\t\t\t// roughness: 0.2,\n\t\t\t// metalness: 0.1,\n\t\t});\n\t\t*/\n\t\t/*\n\t\tconst modifier = new THREE.SubdivisionModifier(2);\n\t\tconst smoothGeometry = modifier.modify(geometry);\n\t\tconst smoothBufferGeometry = new THREE.BufferGeometry().fromGeometry(smoothGeometry);\n\t\tconst mesh = new THREE.Mesh(smoothBufferGeometry, material);\n\t\t*/\n\t\tconst mesh = new THREE.Mesh(geometry, material);\n\t\tmesh.geometry.rotateX(Math.PI / 2);\n\t\tcontroller.add(mesh);\n\t\t//\n\t\tconst geometryIndicator = new THREE.CylinderBufferGeometry(cm(0.5), cm(0.1), 10, 12);\n\t\tconst materialIndicator = new THREE.MeshBasicMaterial({\n\t\t\tcolor: 0xffffff,\n\t\t\t// matcap: texture,\n\t\t\ttransparent: true,\n\t\t\topacity: 0.5,\n\t\t});\n\t\tconst indicator = new THREE.Mesh(geometryIndicator, materialIndicator);\n\t\tcontroller.indicator = indicator;\n\t\tindicator.geometry.rotateX(Math.PI / 2);\n\t\tindicator.position.set(0, 0, -5);\n\t\t// controller.add(indicator);\n\t\t//\n\t}\n\n\taddHands() {\n\t\tconst hands = [];\n\t\tconst left = this.left;\n\t\tconst right = this.right;\n\t\tconst file = 'https://cdn.glitch.com/7ae766be-18fb-4945-ad9d-8cc3be027694%2Fhand.obj?1558677422910';\n\t\tconst loader = new THREE.OBJLoader();\n\t\tloader.load(file, (group) => {\n\t\t\tconst texture = new THREE.TextureLoader().load('https://cdn.glitch.com/7ae766be-18fb-4945-ad9d-8cc3be027694%2FBazC_SkinMat.jpg?1558678160164');\n\t\t\tconst hand = group.children[0];\n\t\t\thand.geometry.rotateZ(-Math.PI / 2);\n\t\t\thand.geometry.rotateY(Math.PI);\n\t\t\thand.geometry.translate(1, -0.2, 0.25);\n\t\t\thand.geometry.scale(0.1, 0.1, 0.1);\n\t\t\thand.material = new THREE.MeshMatcapMaterial({ matcap: texture });\n\t\t\thand.scale.x = -1;\n\t\t\tconst leftHand = hand.clone();\n\t\t\tright.add(leftHand);\n\t\t\thands.push(leftHand);\n\t\t\thand.scale.x = 1;\n\t\t\t// const bills = this.addBillsToHand(hand);\n\t\t\tconst rightHand = hand.clone();\n\t\t\tleft.add(rightHand);\n\t\t\thands.push(rightHand);\n\t\t});\n\t\treturn hands;\n\t}\n\n\taddDragListener() {\n\t\tlet longitude, latitude;\n\t\tconst dragListener = new DragListener(this.container, (event) => {\n\t\t\tlongitude = this.longitude;\n\t\t\tlatitude = this.latitude;\n\t\t}, (event) => {\n\t\t\tthis.longitude = -event.distance.x * 0.1 + longitude;\n\t\t\tthis.latitude = event.distance.y * 0.1 + latitude;\n\t\t\tthis.direction = event.distance.x ? (event.distance.x / Math.abs(event.distance.x) * -1) : 1;\n\t\t\t// console.log('longitude', this.longitude, 'latitude', this.latitude, 'direction', this.direction);\n\t\t}, (event) => {\n\t\t\tthis.speed = Math.abs(event.strength.x) * 100;\n\t\t\t// console.log('speed', this.speed);\n\t\t});\n\t\tdragListener.move = () => {};\n\t\treturn dragListener;\n\t}\n\n\taddVRDragListener() {\n\t\t/*\n\t\tlet longitude, latitude;\n\t\tconst dragListener = new DragListener(this.container, (event) => {\n\t\t\tlongitude = this.longitude;\n\t\t\tlatitude = this.latitude;\n\t\t}, (event) => {\n\t\t\tthis.longitude = -event.distance.x * 0.1 + longitude;\n\t\t\tthis.latitude = event.distance.y * 0.1 + latitude;\n\t\t\tthis.direction = event.distance.x ? (event.distance.x / Math.abs(event.distance.x) * -1) : 1;\n\t\t\t// console.log('longitude', this.longitude, 'latitude', this.latitude, 'direction', this.direction);\n\t\t}, (event) => {\n\t\t\tthis.speed = Math.abs(event.strength.x) * 100;\n\t\t\t// console.log('speed', this.speed);\n\t\t});\n\t\t*/\n\t\tconst raycaster = this.raycaster;\n\t\t// const position = this.pivot.worldToLocal(controller.position);\n\t\t// const rotation = this.pivot.worldToLocal(controller.getWorldDirection(new THREE.Vector3()).multiplyScalar(-1));\n\t\tconst dragListener = {\n\t\t\tstart: () => {\n\t\t\t\tconst dragListener = this.dragListener;\n\t\t\t\tdragListener.qd = this.controller.quaternion.clone();\n\t\t\t\tdragListener.qp = this.pivot.quaternion.clone();\n\t\t\t\t/*\n\t\t\t\tdragListener.down = this.controller.getWorldDirection(new THREE.Vector3());\n\t\t\t\tdragListener.rotation = this.pivot.rotation.toVector3();\n\t\t\t\t*/\n\t\t\t\tdragListener.dragging = true;\n\t\t\t},\n\t\t\tmove: () => {\n\t\t\t\tconst dragListener = this.dragListener;\n\t\t\t\tif (dragListener.dragging) {\n\t\t\t\t\tconst qd = dragListener.qd.clone();\n\t\t\t\t\tconst qm = this.controller.quaternion.clone();\n\t\t\t\t\tconst diff = qm.multiply(qd.inverse());\n\t\t\t\t\tconst qp = dragListener.qp.clone();\n\t\t\t\t\tthis.pivot.setRotationFromQuaternion(qp.multiply(diff));\n\t\t\t\t\t/*\n\t\t\t\t\tconst down = dragListener.down;\n\t\t\t\t\tconst move = this.controller.getWorldDirection(new THREE.Vector3());\n\t\t\t\t\tconst rotation = dragListener.rotation.clone();\n\t\t\t\t\trotation.add(move);\n\t\t\t\t\trotation.sub(down);\n\t\t\t\t\tthis.pivot.rotation.set(-rotation.y, rotation.x, rotation.z);\n\t\t\t\t\t*/\n\t\t\t\t}\n\t\t\t},\n\t\t\tend: () => {\n\t\t\t\tconst dragListener = this.dragListener;\n\t\t\t\tdragListener.dragging = false;\n\t\t\t},\n\t\t};\n\t\treturn dragListener;\n\t}\n\n\tonInitView(previous, current) {\n\t\t// console.log(previous, current);\n\t\tthis.onExitPanel();\n\t\tthis.onExitPoints(previous).then(() => {\n\t\t\t// console.log(this.points.vertices);\n\t\t\tthis.onExitView(previous).then(() => {\n\t\t\t\t// if (!previous) {\n\t\t\t\tthis.onEnterView(current).then(() => {\n\t\t\t\t\tthis.onEnterPoints(current);\n\t\t\t\t\t// console.log(this.points.vertices);\n\t\t\t\t});\n\t\t\t\t// }\n\t\t\t});\n\t\t});\n\t}\n\n\tonExitView(view) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tif (view) {\n\t\t\t\tTweenMax.to(this.room.sphere.material, 0.4, {\n\t\t\t\t\topacity: 0,\n\t\t\t\t\tdelay: 0.0,\n\t\t\t\t\tonCompleted: () => {\n\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\tresolve(view);\n\t\t\t\t\t\t}, 250);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tresolve(view);\n\t\t\t}\n\t\t});\n\t}\n\n\tonEnterView(view) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tif (view) {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t// const tourTextureSrc = container.getAttribute('texture');\n\t\t\t\t\tconst loader = new THREE.TextureLoader();\n\t\t\t\t\tloader.crossOrigin = '';\n\t\t\t\t\tloader.load(view.image, (texture) => {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t// texture.wrapS = texture.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\t\t// texture.repeat.set(2, 2);\n\t\t\t\t\t\tthis.tourTexture = texture;\n\t\t\t\t\t\tthis.createScene();\n\t\t\t\t\t\t*/\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tif (this.room.sphere.material.map) {\n\t\t\t\t\t\t\tthis.room.sphere.material.map.dispose();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tif (view.orientation) {\n\t\t\t\t\t\t\tthis.latitude = view.orientation.latitude;\n\t\t\t\t\t\t\tthis.longitude = view.orientation.longitude;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst material = this.room.sphere.material;\n\t\t\t\t\t\tmaterial.opacity = 0;\n\t\t\t\t\t\tmaterial.color.setHex(0xffffff);\n\t\t\t\t\t\t// texture.minFilter = THREE.NearestMipMapNearestFilter;\n\t\t\t\t\t\t// texture.magFilter = THREE.LinearMipMapLinearFilter;\n\t\t\t\t\t\tmaterial.map = texture;\n\t\t\t\t\t\tmaterial.map.needsUpdate = true;\n\t\t\t\t\t\tmaterial.needsUpdate = true;\n\t\t\t\t\t\tTweenMax.to(material, 0.6, {\n\t\t\t\t\t\t\topacity: TEST_ENABLED ? 0.5 : 1,\n\t\t\t\t\t\t\tdelay: 0.1,\n\t\t\t\t\t\t\tonCompleted: () => {\n\t\t\t\t\t\t\t\tresolve(view);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}, 100);\n\t\t\t} else {\n\t\t\t\treject(view);\n\t\t\t}\n\t\t});\n\t}\n\n\tonEnterPoints(view) {\n\t\tview.points.forEach((point, i) => this.addPoint(this.points, new THREE.Vector3(...point.position), i));\n\t}\n\n\tonExitPoints(view) {\n\t\tif (view) {\n\t\t\treturn Promise.all(view.points.map((point, i) => this.removePoint(i)));\n\t\t} else {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t}\n\n\tonEnterPanel(point) {\n\t\tthis.getPanelInfoById('#panel').then(info => {\n\t\t\tif (info) {\n\t\t\t\tconst panel = this.panel;\n\t\t\t\tpanel.material.map = info.map;\n\t\t\t\tpanel.material.opacity = 0;\n\t\t\t\t// panel.material.alphaMap = info.alphaMap;\n\t\t\t\tpanel.material.needsUpdate = true;\n\t\t\t\t// const scale = info.width / 256;\n\t\t\t\t// panel.geometry.scale(scale, scale, scale);\n\t\t\t\t// panel.geometry.verticesNeedUpdate = true;\n\t\t\t\tconst position = point.normalize().multiplyScalar(PANEL_RADIUS);\n\t\t\t\tpanel.position.set(position.x, position.y + 30 + 30, position.z);\n\t\t\t\tpanel.lookAt(this.origin);\n\t\t\t\tthis.pivot.add(panel);\n\t\t\t\tconst from = { value: 1 };\n\t\t\t\tTweenMax.to(from, 0.2, {\n\t\t\t\t\tvalue: 0,\n\t\t\t\t\tdelay: 0.2,\n\t\t\t\t\tonUpdate: () => {\n\t\t\t\t\t\tpanel.position.set(position.x, position.y + 30 + 30 * from.value, position.z);\n\t\t\t\t\t\tpanel.lookAt(this.origin);\n\t\t\t\t\t\tpanel.material.opacity = 1 - from.value;\n\t\t\t\t\t\tpanel.material.needsUpdate = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t// console.log('getPanelInfoById', panel.position);\n\t\t\t}\n\t\t});\n\t}\n\n\tonExitPanel() {\n\t\tconst panel = this.panel;\n\t\tif (panel && panel.parent) {\n\t\t\tpanel.parent.remove(panel);\n\t\t}\n\t}\n\n\t// events\n\n\tonLeftSelectStart(id) {\n\t\ttry {\n\t\t\t// 1 front, 2 side, 3 Y, 4 X, 5?\n\t\t\tthis.setText(String(id));\n\t\t\tif (this.controller !== this.left) {\n\t\t\t\tif (this.controller) {\n\t\t\t\t\tthis.controller.remove(this.controller.indicator);\n\t\t\t\t}\n\t\t\t\tthis.controller = this.left;\n\t\t\t\tthis.controller.add(this.controller.indicator);\n\t\t\t}\n\t\t\tthis.isControllerSelecting = true;\n\t\t\tthis.isControllerSelectionDirty = true;\n\t\t\t// this.dragListener.start();\n\t\t} catch (error) {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t}\n\t}\n\n\tonLeftSelectEnd() {\n\t\ttry {\n\t\t\tif (this.controller === this.left) {\n\t\t\t\tthis.isControllerSelecting = false;\n\t\t\t\tthis.isControllerSelectionDirty = false;\n\t\t\t}\n\t\t\t// this.dragListener.end();\n\t\t} catch (error) {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t}\n\t}\n\n\tonRightSelectStart(id) {\n\t\ttry {\n\t\t\t// 1 front, 2 side, 3 A, 4 B, 5?\n\t\t\tthis.setText(String(id));\n\t\t\tif (this.controller !== this.right) {\n\t\t\t\tif (this.controller) {\n\t\t\t\t\tthis.controller.remove(this.controller.indicator);\n\t\t\t\t}\n\t\t\t\tthis.controller = this.right;\n\t\t\t\tthis.controller.add(this.controller.indicator);\n\t\t\t}\n\t\t\tthis.isControllerSelecting = true;\n\t\t\tthis.isControllerSelectionDirty = true;\n\t\t\t// this.dragListener.start();\n\t\t} catch (error) {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t}\n\t}\n\n\tonRightSelectEnd() {\n\t\ttry {\n\t\t\tif (this.controller === this.right) {\n\t\t\t\tthis.isControllerSelecting = false;\n\t\t\t\tthis.isControllerSelectionDirty = false;\n\t\t\t}\n\t\t\t// this.dragListener.end();\n\t\t} catch (error) {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t}\n\t}\n\n\tonWindowResize() {\n\t\ttry {\n\t\t\tconst container = this.container,\n\t\t\t\trenderer = this.renderer,\n\t\t\t\tcamera = this.camera;\n\t\t\tconst size = this.size;\n\t\t\tsize.width = container.offsetWidth;\n\t\t\tsize.height = container.offsetHeight;\n\t\t\tsize.aspect = size.width / size.height;\n\t\t\tif (renderer) {\n\t\t\t\trenderer.setSize(size.width, size.height);\n\t\t\t}\n\t\t\tif (camera) {\n\t\t\t\tcamera.aspect = size.width / size.height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t}\n\t}\n\n\tonMouseDown(event) {\n\t\tif (TEST_ENABLED) {\n\t\t\t// this.dragListener.start();\n\t\t\tthis.setText('down');\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tconst raycaster = this.raycaster;\n\t\t\t// update the picking ray with the camera and mouse position\n\t\t\traycaster.setFromCamera(this.mouse, this.camera);\n\t\t\t// calculate objects intersecting the picking ray\n\t\t\tif (event.shiftKey) {\n\t\t\t\tconst intersections = raycaster.intersectObjects(this.room.children);\n\t\t\t\tif (intersections) {\n\t\t\t\t\tconst intersection = intersections.find(x => x !== undefined);\n\t\t\t\t\tthis.createPoint(intersection);\n\t\t\t\t}\n\t\t\t\t// console.log(intersections);\n\t\t\t\t/*\n\t\t\t\tfor (var i = 0; i < intersects.length; i++ ) {\n\t\t\t\t\tconsole.log(intersections[i])\n\t\t\t\t\tintersects[i].object.material.color.set( 0xff0000 );\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t} else if (this.points) {\n\t\t\t\traycaster.params.Points.threshold = 10.0;\n\t\t\t\tconst intersections = raycaster.intersectObjects(this.points.children);\n\t\t\t\tif (intersections) {\n\t\t\t\t\tconst intersection = intersections.find(x => x !== undefined);\n\t\t\t\t\tif (intersection) {\n\t\t\t\t\t\tconst index = intersection.index;\n\t\t\t\t\t\tconst point = intersection.point;\n\t\t\t\t\t\tconst debugInfo = `${index} => {${point.x}, ${point.y}, ${point.z}}`;\n\t\t\t\t\t\t// console.log(index, point, debugInfo);\n\t\t\t\t\t\tthis.debugInfo.innerHTML = debugInfo;\n\t\t\t\t\t\tthis.index = (this.index + 1) % this.views.length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t}\n\t}\n\n\tonMouseMove(event) {\n\t\ttry {\n\t\t\tconst w2 = this.container.offsetWidth / 2;\n\t\t\tconst h2 = this.container.offsetHeight / 2;\n\t\t\tthis.mouse = {\n\t\t\t\tx: (event.clientX - w2) / w2,\n\t\t\t\ty: -(event.clientY - h2) / h2,\n\t\t\t};\n\t\t\tif (TEST_ENABLED && this.controller) {\n\t\t\t\tthis.controller.rotation.y = -this.mouse.x * Math.PI;\n\t\t\t\tthis.controller.rotation.x = this.mouse.y * Math.PI / 2;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst raycaster = this.raycaster;\n\t\t\traycaster.setFromCamera(this.mouse, this.camera);\n\t\t\tthis.updateHoverPoint(raycaster);\n\t\t\t/*\n\t\t\tif (TEST_ENABLED) {\n\t\t\t\tconst controller = this.controller;\n\t\t\t\tconst raycaster = this.raycaster;\n\t\t\t\tconst rotation = controller.getWorldDirection(new THREE.Vector3()).multiplyScalar(-1);\n\t\t\t\traycaster.set(controller.position, rotation);\n\t\t\t\tlet intersections = raycaster.intersectObjects([this.room.sphere]);\n\t\t\t\tif (intersections) {\n\t\t\t\t\tconst intersection = intersections.find(x => x !== undefined);\n\t\t\t\t\tif (intersection) {\n\t\t\t\t\t\tconst position = intersection.point.normalize();\n\t\t\t\t\t\tconsole.log('s', position.x, position.y, position.z);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this.points && this.points.children.length) {\n\t\t\t\t\tconst point = this.points.children[0];\n\t\t\t\t\tconst position = point.position.clone().normalize();\n\t\t\t\t\tconsole.log('p', position.x, position.y, position.z);\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\t\t\t// console.log('onMouseMove', this.mouse);\n\t\t\t/*\n\t\t\tvar attributes = geometry.attributes;\n\t\t\traycaster.setFromCamera( mouse, camera );\n\t\t\tintersects = raycaster.intersectObject( points );\n\t\t\tif ( intersects.length > 0 ) {\n\t\t\t\tif ( INTERSECTED != intersects[ 0 ].index ) {\n\t\t\t\t\tattributes.size.array[ INTERSECTED ] = PARTICLE_SIZE;\n\t\t\t\t\tINTERSECTED = intersects[ 0 ].index;\n\t\t\t\t\tattributes.size.array[ INTERSECTED ] = PARTICLE_SIZE * 1.25;\n\t\t\t\t\tattributes.size.needsUpdate = true;\n\t\t\t\t}\n\t\t\t} else if ( INTERSECTED !== null ) {\n\t\t\t\tattributes.size.array[ INTERSECTED ] = PARTICLE_SIZE;\n\t\t\t\tattributes.size.needsUpdate = true;\n\t\t\t\tINTERSECTED = null;\n\t\t\t}\n\t\t\t*/\n\t\t} catch (error) {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t}\n\t}\n\n\tonMouseUp(event) {\n\t\tif (TEST_ENABLED) {\n\t\t\t// this.dragListener.end();\n\t\t\tthis.setText('up');\n\t\t\treturn;\n\t\t}\n\t}\n\n\tonMouseWheel(event) {\n\t\ttry {\n\t\t\tconst camera = this.camera;\n\t\t\tconst fov = camera.fov + event.deltaY * 0.01;\n\t\t\tcamera.fov = THREE.Math.clamp(fov, 30, 75);\n\t\t\tcamera.updateProjectionMatrix();\n\t\t} catch (error) {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t}\n\t}\n\n\tonSave(event) {\n\t\ttry {\n\t\t\tthis.view.orientation = {\n\t\t\t\tlatitude: this.latitude,\n\t\t\t\tlongitude: this.longitude,\n\t\t\t};\n\t\t\tthis.saveData({ views: this.views }, 'vr.json');\n\t\t} catch (error) {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t}\n\t}\n\n\t// animation\n\n\tfindGamepad(id) {\n\t\tconst gamepads = navigator.getGamepads && navigator.getGamepads();\n\t\tif (!gamepads) {\n\t\t\treturn undefined;\n\t\t}\n\t\tfor (var i = 0, j = 0, l = gamepads.length; i < l; i++) {\n\t\t\tconst gamepad = gamepads[i];\n\t\t\tif (gamepad && (\n\t\t\t\t\tgamepad.id === 'Daydream Controller' ||\n\t\t\t\t\tgamepad.id === 'Gear VR Controller' || gamepad.id === 'Oculus Go Controller' ||\n\t\t\t\t\tgamepad.id === 'OpenVR Gamepad' || gamepad.id.startsWith('Oculus Touch') ||\n\t\t\t\t\tgamepad.id.startsWith('Spatial Controller')\n\t\t\t\t)) {\n\t\t\t\tif (j === id) {\n\t\t\t\t\treturn gamepad;\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t}\n\n\tupdateTriggers() {\n\t\tconst gamePadLeft = this.findGamepad(0);\n\t\tif (gamePadLeft) {\n\t\t\tconst triggerLeft = gamePadLeft ? gamePadLeft.buttons.reduce((p, b, i) => b.pressed ? i : p, -1) : -1;\n\t\t\tif (triggerLeft !== -1) {\n\t\t\t\tthis.onLeftSelectStart(triggerLeft);\n\t\t\t} else {\n\t\t\t\tthis.onLeftSelectEnd();\n\t\t\t}\n\t\t}\n\t\tconst gamePadRight = this.findGamepad(1);\n\t\tif (gamePadRight) {\n\t\t\tconst triggerRight = gamePadRight ? gamePadRight.buttons.reduce((p, b, i) => b.pressed ? i : p, -1) : -1;\n\t\t\tif (triggerRight !== -1) {\n\t\t\t\tthis.onRightSelectStart(triggerRight);\n\t\t\t} else {\n\t\t\t\tthis.onRightSelectEnd();\n\t\t\t}\n\t\t}\n\t}\n\n\tanimate() {\n\t\tconst renderer = this.renderer;\n\t\trenderer.setAnimationLoop(() => {\n\t\t\tthis.render();\n\t\t});\n\t}\n\n\trender(delta) {\n\t\tconst cameraDirection = this.camera.getWorldDirection(this.cameraDirection);\n\t\tif (this.vr.mode !== VR_MODE.NONE) {\n\t\t\t// this.dragListener.move();\n\t\t\tthis.updateTriggers();\n\t\t\tthis.menu.active = this.controller && this.pointer.position.y > 15;\n\t\t\tthis.menu.update(cameraDirection);\n\t\t\t// this.updateMenu();\n\t\t\tthis.updateController();\n\t\t} else if (TEST_ENABLED) {\n\t\t\t// this.dragListener.move();\n\t\t\t// this.updatePivot();\n\t\t\tthis.updateCamera();\n\t\t\t// this.updateTriggers();\n\t\t\tthis.menu.active = this.controller && this.pointer.position.y > 15;\n\t\t\tthis.menu.update(cameraDirection);\n\t\t\t// this.updateMenu();\n\t\t\tthis.updateController();\n\t\t} else {\n\t\t\t// this.updatePivot();\n\t\t\t// this.testController();\n\t\t\tthis.updateCamera();\n\t\t}\n\t\tconst renderer = this.renderer;\n\t\trenderer.render(this.scene, this.camera);\n\t\t// this.doParallax();\n\t}\n\n\tupdateMenu() {\n\t\tconst menu = this.menu.mesh;\n\t\tconst arc = this.menu.arc;\n\t\tconst controller = this.controller;\n\t\tconst pointer = this.pointer;\n\t\tconst active = controller && pointer.position.y > 15;\n\t\tconst vector = this.camera.getWorldDirection(this.cameraDirection);\n\t\tconst endTheta = Math.atan2(vector.x, vector.z) - this.pivot.rotation.y + Math.PI - this.menu.ry;\n\t\t// const t = this.t ? this.t++ : 0;\n\t\t// const theta = menu.rotation.y + (endTheta - menu.rotation.y) / 10;\n\t\tmenu.rotation.set(0, endTheta, 0);\n\t\tconst endY = active ? 20 : this.menu.py;\n\t\tconst y = menu.position.y + (endY - menu.position.y) / 10;\n\t\tmenu.position.set(0, y, 0);\n\t\tconst endOpacity = active ? 1 : 0;\n\t\tconst opacity = arc.material.opacity + (endOpacity - arc.material.opacity) / 10;\n\t\t// console.log(endTheta, active, y, opacity);\n\t\tarc.material.opacity = opacity;\n\t\tarc.material.needsUpdate = true;\n\t}\n\n\tupdatePointer(raycaster) {\n\t\tconst intersections = raycaster.intersectObjects(this.room.children);\n\t\tif (intersections.length) {\n\t\t\tconst intersection = intersections[0];\n\t\t\t// const intersection = intersections.find(x => x !== undefined);\n\t\t\tif (intersection) {\n\t\t\t\t// const index = intersection.index;\n\t\t\t\t// const point = intersection.point;\n\t\t\t\t// const debugInfo = `${index} => {${point.x}, ${point.y}, ${point.z}}`;\n\t\t\t\t// console.log(index, point, debugInfo);\n\t\t\t\t// this.debugInfo.innerHTML = debugInfo;\n\t\t\t\t// console.log(intersection.point);\n\t\t\t\tlet position = intersection.point.normalize().multiplyScalar(POINTER_RADIUS);\n\t\t\t\tposition = this.pivot.worldToLocal(position);\n\t\t\t\tthis.pointer.position.set(position.x, position.y, position.z);\n\t\t\t\tthis.pointer.lookAt(this.origin);\n\t\t\t\t// console.log(position.x, position.y, position.z);\n\t\t\t}\n\t\t}\n\t\tthis.pointer.material.color.setHex(this.isControllerSelecting ? 0x0000ff : 0xffffff);\n\t\tthis.pointer.material.opacity = this.isControllerSelecting ? 1.0 : 0.5;\n\t}\n\n\tupdateHoverPoint(raycaster) {\n\t\tlet point;\n\t\t// raycaster.params.Points.threshold = 10.0;\n\t\tconst intersections = raycaster.intersectObjects(this.points.children);\n\t\t/*\n\t\tif (intersections.length) {\n\t\t\tconst intersection = intersections[0];\n\t\t\tpoint = intersection.object;\n\t\t\tpoint = this.points.children.find(x => x === point);\n\t\t}\n\t\t*/\n\t\t// console.log(intersections);\n\t\tconst intersection = intersections.length ? intersections[0] : null;\n\t\tthis.hoverPoint = intersection;\n\t\tthis.selectedPoint = intersection;\n\t}\n\n\tupdateController() {\n\t\ttry {\n\t\t\tconst controller = this.controller;\n\t\t\tif (controller) {\n\t\t\t\tconst raycaster = this.raycaster;\n\t\t\t\t/*\n\t\t\t\tif (TEST_ENABLED) {\n\t\t\t\t\traycaster.setFromCamera(this.mouse, this.camera);\n\t\t\t\t\tcontroller.position.copy(this.camera.position);\n\t\t\t\t\tcontroller.rotation.copy(this.camera.rotation);\n\t\t\t\t} else {\n\t\t\t\t\tconst position = controller.position; // this.pivot.worldToLocal(controller.position);\n\t\t\t\t\tconst rotation = controller.getWorldDirection(this.controllerDirection).multiplyScalar(-1); // this.pivot.worldToLocal(controller.getWorldDirection(this.controllerDirection).multiplyScalar(-1));\n\t\t\t\t\traycaster.set(position, rotation);\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\tconst position = controller.position; // this.pivot.worldToLocal(controller.position);\n\t\t\t\tconst rotation = controller.getWorldDirection(this.controllerDirection).multiplyScalar(-1); // this.pivot.worldToLocal(controller.getWorldDirection(this.controllerDirection).multiplyScalar(-1));\n\t\t\t\t// new THREE.Vector3(controller.rotation.x, controller.rotation.y, controller.rotation.z).normalize();\n\t\t\t\traycaster.set(position, rotation);\n\t\t\t\tInteractiveMesh.hittest(raycaster, this.isControllerSelecting);\n\t\t\t\tthis.updatePointer(raycaster);\n\t\t\t\tthis.updateHoverPoint(raycaster);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t}\n\t}\n\n\tupdatePivot() {\n\t\tconst pivot = this.pivot;\n\t\tconst direction = this.direction;\n\t\tconst inertia = this.inertia;\n\t\tlet speed = this.speed;\n\t\tlet latitude = this.latitude;\n\t\tlet longitude = this.longitude;\n\t\tif (this.dragListener && this.dragListener.dragging === false) {\n\t\t\t// longitude += 0.01 * direction * speed;\n\t\t\tspeed = Math.max(1, speed * 0.98);\n\t\t\tinertia.multiplyScalar(0.98);\n\t\t}\n\t\tlatitude = Math.max(-85, Math.min(85, latitude));\n\t\tconst phi = THREE.Math.degToRad(90 - latitude);\n\t\tconst theta = THREE.Math.degToRad(longitude);\n\t\tpivot.rotation.set(phi - Math.PI / 2, theta + Math.PI / 2, 0);\n\t\t/*\n\t\tpivot.target.x = ROOM_RADIUS * Math.sin(phi) * Math.cos(theta);\n\t\tpivot.target.y = ROOM_RADIUS * Math.cos(phi);\n\t\tpivot.target.z = ROOM_RADIUS * Math.sin(phi) * Math.sin(theta);\n\t\tpivot.lookAt(pivot.target);\n\t\t*/\n\t\tthis.latitude = latitude;\n\t\tthis.longitude = longitude;\n\t\tthis.speed = speed;\n\t\tthis.inertia = inertia;\n\t}\n\n\tupdateCamera() {\n\t\tconst camera = this.camera;\n\t\tconst direction = this.direction;\n\t\tconst inertia = this.inertia;\n\t\tlet speed = this.speed;\n\t\tlet latitude = this.latitude;\n\t\tlet longitude = this.longitude;\n\t\tif (this.dragListener && this.dragListener.dragging === false) {\n\t\t\t// longitude += 0.01 * direction * speed;\n\t\t\tspeed = Math.max(1, speed * 0.98);\n\t\t\tinertia.multiplyScalar(0.98);\n\t\t}\n\t\tlatitude = Math.max(-85, Math.min(85, latitude));\n\t\tconst phi = THREE.Math.degToRad(90 - latitude);\n\t\tconst theta = THREE.Math.degToRad(longitude);\n\t\tcamera.target.x = ROOM_RADIUS * Math.sin(phi) * Math.cos(theta);\n\t\tcamera.target.y = ROOM_RADIUS * Math.cos(phi);\n\t\tcamera.target.z = ROOM_RADIUS * Math.sin(phi) * Math.sin(theta);\n\t\tcamera.lookAt(camera.target);\n\t\tthis.latitude = latitude;\n\t\tthis.longitude = longitude;\n\t\tthis.speed = speed;\n\t\tthis.inertia = inertia;\n\t\t/*\n\t\t// distortion\n\t\tcamera.position.copy( camera.target ).negate();\n\t\t*/\n\t}\n\n\t// utils\n\n\tsaveData(data, filename = 'console.json') {\n\t\tif (!data) {\n\t\t\tconsole.error('Console.save: No data');\n\t\t\treturn;\n\t\t}\n\t\tif (typeof data === 'object') {\n\t\t\tdata = JSON.stringify(data, undefined, 4);\n\t\t}\n\t\tconst blob = new Blob([data], { type: 'text/json' });\n\t\tconst event = document.createEvent('MouseEvents');\n\t\tconst anchor = document.createElement('a');\n\t\tanchor.download = filename;\n\t\tanchor.href = window.URL.createObjectURL(blob);\n\t\tanchor.dataset.downloadurl = ['text/json', anchor.download, anchor.href].join(':');\n\t\tevent.initMouseEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n\t\tanchor.dispatchEvent(event);\n\t}\n\n\tgetPanelInfoById(id) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst node = document.querySelector(id);\n\t\t\tif (node) {\n\t\t\t\thtml2canvas(node, {\n\t\t\t\t\tbackgroundColor: '#ffffff00',\n\t\t\t\t}).then(canvas => {\n\t\t\t\t\t// !!!\n\t\t\t\t\t// document.body.appendChild(canvas);\n\t\t\t\t\t// const alpha = this.getAlphaFromCanvas(canvas);\n\t\t\t\t\t// document.body.appendChild(alpha);\n\t\t\t\t\tconst map = new THREE.CanvasTexture(canvas);\n\t\t\t\t\t// const alphaMap = new THREE.CanvasTexture(alpha);\n\t\t\t\t\tresolve({\n\t\t\t\t\t\tmap: map,\n\t\t\t\t\t\t// alphaMap: alphaMap,\n\t\t\t\t\t\twidth: canvas.width,\n\t\t\t\t\t\theight: canvas.height,\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treject('node not found');\n\t\t\t}\n\t\t})\n\t}\n\n\tgetAlphaFromCanvas(source) {\n\t\tconst sourceCtx = source.getContext('2d');\n\t\tconst imageData = sourceCtx.getImageData(0, 0, source.width, source.height);\n\t\tconst data = imageData.data;\n\t\tfor (let i = 0; i < data.length; i += 4) {\n\t\t\tconst alpha = data[i + 3];\n\t\t\tdata[i] = alpha;\n\t\t\tdata[i + 1] = alpha;\n\t\t\tdata[i + 2] = alpha;\n\t\t\tdata[i + 3] = 254;\n\t\t}\n\t\tconst target = document.createElement('canvas');\n\t\ttarget.width = source.width;\n\t\ttarget.height = source.height;\n\t\tconst targetCtx = target.getContext('2d');\n\t\ttargetCtx.putImageData(imageData, target.width, target.height);\n\t\t// targetCtx.drawImage(imageData, 0, 0);\n\t\treturn target;\n\t}\n\n}\n\nconst tour = new VRTour();\ntour.animate();\ntour.load('data/vr.json');\n\n/*\n\ndoParallax() {\n\t// parallax\n\tconst parallax = this.parallax;\n\tparallax.x += (this.mouse.x - parallax.x) / 8;\n\tparallax.y += (this.mouse.y - parallax.y) / 8;\n\t// this.light1.position.set(parallax.x * 5.0, 6.0 + parallax.y * 2.0, 4.0);\n\t// this.light2.position.set(parallax.x * -5.0, -6.0 - parallax.y * 2.0, 4.0);\n}\n\nconst shaderPoint = {\n\tvertexShader: `\n\tattribute float size;\n\tattribute vec4 ca;\n\tvarying vec4 vColor;\n\tvoid main() {\n\t\tvColor = ca;\n\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\t\tgl_PointSize = size * (400.0 / -mvPosition.z);\n\t\tgl_Position = projectionMatrix * mvPosition;\n\t}\n\t`,\n\tfragmentShader: `\n\tuniform vec3 color;\n\tuniform sampler2D texture;\n\tvarying vec4 vColor;\n\tvoid main() {\n\t\tvec4 textureColor = texture2D(texture, gl_PointCoord);\n\t\t// if (textureColor.a < 0.5) discard;\n\t\tgl_FragColor = textureColor * vec4(color * vColor.xyz, 1.0);\n\t\t// float depth = gl_FragCoord.z / gl_FragCoord.w;\n\t\tgl_FragColor = vec4(vec3(1.0), gl_FragColor.w);\n\t}\n\t`,\n};\n\nconst material = new THREE.PointsMaterial({\n\tsize: 15,\n\tmap: loader.load('img/pin.png'),\n\tvertexColors: THREE.VertexColors,\n\tblending: THREE.AdditiveBlending,\n\tdepthTest: true,\n\ttransparent: true\n});\n*/\n/*\nconst material = new THREE.ShaderMaterial({\n\tuniforms: {\n\t\tcolor: { value: new THREE.Color(0xffffff) },\n\t\ttexture: { value: loader.load('img/pin.png') }\n\t},\n\tvertexColors: THREE.VertexColors,\n\tblending: THREE.AdditiveBlending,\n\tdepthTest: true,\n\ttransparent: true,\n\tvertexShader: shaderPoint.vertexShader,\n\tfragmentShader: shaderPoint.fragmentShader,\n\talphaTest: 0.9\n});\n*/\n/*\n\taddPoints_(parent) {\n\t\tconst loader = new THREE.TextureLoader();\n\t\tconst geometry = new THREE.BufferGeometry();\n\t\t// hack fix\n\t\tconst vertices = [];\n\t\tvertices.push(0, -10000, 0);\n\t\tvertices.push(0, 10000, 0);\n\t\tgeometry.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n\t\t// hack fix\n\t\tconst colors = new Array(100 * 3).fill(0);\n\t\tconst colorsAttribute = new THREE.Float32BufferAttribute(colors, 3);\n\t\tconst sizes = new Array(100).fill(10);\n\t\tgeometry.addAttribute('color', colorsAttribute);\n\t\tgeometry.addAttribute('customColor', new THREE.Float32BufferAttribute(colors, 3));\n\t\tgeometry.addAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));\n\t\tconst material = new THREE.ShaderMaterial({\n\t\t\tuniforms: {\n\t\t\t\tamplitude: { value: 1.0 },\n\t\t\t\tcolor: { value: new THREE.Color(0xffffff) },\n\t\t\t\ttexture: { value: loader.load('img/pin.png') }\n\t\t\t},\n\t\t\tvertexShader: shaderPoint.vertexShader,\n\t\t\tfragmentShader: shaderPoint.fragmentShader,\n\t\t\ttransparent: true\n\t\t});\n\t\t// materials[i].color.setHSL(1, 0, 0);\n\t\tconst points = new THREE.Points(geometry, material);\n\t\tpoints.vertices = vertices;\n\t\tpoints.colors = colors;\n\t\tpoints.colorsAttribute = colorsAttribute;\n\t\tpoints.scale.set(0.95, 0.95, 0.95);\n\t\tparent.add(points);\n\t\treturn points;\n\t}\n\n\taddPoint_(position, i) {\n\t\tconst points = this.points;\n\t\tconst geometry = points.geometry;\n\t\tconst vertices = points.vertices;\n\t\tconst index = vertices.length / 3;\n\t\tvertices.push(position.x, position.y, position.z);\n\t\tgeometry.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n\t\tconst colorsAttribute = points.colorsAttribute;\n\t\tcolorsAttribute.setXYZ(index, 0, 0, 0);\n\t\tpoints.material.needsUpdate = true;\n\t\t// console.log(index, 'start');\n\t\tconst from = { opacity: 0 };\n\t\tTweenMax.to(from, 0.5, {\n\t\t\topacity: 1,\n\t\t\tdelay: 0.1 * i,\n\t\t\tonUpdate: () => {\n\t\t\t\t// console.log(index, from.opacity);\n\t\t\t\tcolorsAttribute.setXYZ(index, from.opacity, from.opacity, from.opacity);\n\t\t\t\tcolorsAttribute.needsUpdate = true;\n\t\t\t\tpoints.material.needsUpdate = true;\n\t\t\t},\n\t\t\tonCompleted: () => {\n\t\t\t\t// console.log(index, 'completed');\n\t\t\t}\n\t\t});\n\t}\n\n\tremovePoint_(i) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst points = this.points;\n\t\t\tconst geometry = points.geometry;\n\t\t\tconst vertices = points.vertices;\n\t\t\tconst index = vertices.length / 3;\n\t\t\tconst colorsAttribute = points.colorsAttribute;\n\t\t\tcolorsAttribute.setXYZ(index, 1, 1, 1);\n\t\t\tpoints.material.needsUpdate = true;\n\t\t\t// console.log(index, 'start');\n\t\t\tconst from = { opacity: 1 };\n\t\t\tTweenMax.to(from, 0.5, {\n\t\t\t\topacity: 0,\n\t\t\t\tdelay: 0.0 * i,\n\t\t\t\tonUpdate: () => {\n\t\t\t\t\t// console.log(index, from.opacity);\n\t\t\t\t\tcolorsAttribute.setXYZ(index, from.opacity, from.opacity, from.opacity);\n\t\t\t\t\tcolorsAttribute.needsUpdate = true;\n\t\t\t\t\tpoints.material.needsUpdate = true;\n\t\t\t\t},\n\t\t\t\tonCompleted: () => {\n\t\t\t\t\t// console.log(index, 'completed');\n\t\t\t\t\tvertices.splice(vertices.length - 3, 3);\n\t\t\t\t\tgeometry.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tcreatePoint_(intersection) {\n\t\t// console.log(intersection);\n\t\tconst position = intersection.point.clone();\n\t\tthis.addPoint(this.points, position, 0);\n\t\tthis.view.points.push({\n\t\t\tid: 2,\n\t\t\tposition: position.toArray(),\n\t\t\ttype: 1,\n\t\t\tname: 'Point 2',\n\t\t\tkey: 'POINT2',\n\t\t});\n\t\t// p.multiplyScalar(1);\n\t}\n\n\nlet camera;\nif (USE_ORTHO) {\n\tconst width = 10;\n\tconst height = width / this.container.offsetWidth * this.container.offsetHeight;\n\tcamera = new THREE.OrthographicCamera(-width, width, height, -height, 0.01, 1000);\n} else {\n\tcamera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 1000);\n}\n// const camera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, 0.01, 1000);\ncamera.position.set(0, 5.0, 12.0);\ncamera.up = new THREE.Vector3(0, 0, -1);\ncamera.lookAt(new THREE.Vector3(0, 0, 0));\nthis.camera = camera;\n*/\n\n/*\nconst ambient = new THREE.AmbientLight(0x222222);\nscene.add(ambient);\nthis.ambient = ambient;\n*/\n\n/*\n// color : Integer, intensity : Float, distance : Number, decay : Float\nconst light = new THREE.PointLight(0xffffff, 1000, 1000, 1);\nlight.position.set(0, 0, 0);\nscene.add(light);\nthis.light = light;\n*/\n\n/*\nlet light1;\nlight1 = new THREE.DirectionalLight(0xffffff, 4.0);\n// light1.castShadow = true;\n// light1.shadowCameraVisible = true;\n// light1.mapSize.width = 2048;\n// light1.mapSize.height = 2048;\nscene.add(light1);\nthis.light1 = light1;\nif (SHOW_HELPERS) {\n\tconst light1Helper = new THREE.DirectionalLightHelper(light1, 1);\n\tscene.add(light1Helper);\n}\nconst light2 = new THREE.DirectionalLight(0xffffff, 4.0);\nscene.add(light2);\nthis.light2 = light2;\nif (SHOW_HELPERS) {\n\tconst light2Helper = new THREE.DirectionalLightHelper(light2, 1);\n\tscene.add(light2Helper);\n}\n*/\n"],"file":"docs/js/vrtour.js"}