{"version":3,"names":[],"mappings":"","sources":["src/js/vrtour.js"],"sourcesContent":["/* jshint esversion: 6 */\n/* global window, document, TweenMax, ThreeJs */\n\nimport Dom from './shared/dom';\nimport DragListener from './shared/drag.listener';\n\nTHREE.Euler.prototype.add = function(euler) {\n\tthis.set(this.x + euler.x, this.y + euler.y, this.z + euler.z, this.order);\n\treturn this;\n};\n\nconst USE_ORTHO = false;\nconst SHOW_HELPERS = false;\n\nclass VRTour {\n\n\tconstructor() {\n\t\tthis.mouse = { x: 0, y: 0 };\n\t\tthis.parallax = { x: 0, y: 0 };\n\t\tthis.size = { width: 0, height: 0, aspect: 0 };\n\t\tthis.isUserInteracting = false;\n\t\tthis.lon = 0;\n\t\tthis.lat = 0;\n\t\tthis.phi = 0;\n\t\tthis.theta = 0;\n\t\tthis.direction = 1;\n\t\tthis.speed = 1;\n\t}\n\n\tinit() {\n\t\tconst body = document.querySelector('body');\n\t\tconst section = document.querySelector('.vrtour');\n\t\tconst container = section.querySelector('.vrtour__container');\n\t\t// const shadow = section.querySelector('.vrtour__shadow');\n\t\tconst title = section.querySelector('.vrtour__headline .title');\n\t\tconst abstract = section.querySelector('.vrtour__headline .abstract');\n\t\tDom.detect(body);\n\t\tbody.classList.add('ready');\n\t\tconst tourTextureSrc = container.getAttribute('texture');\n\t\tconst loader = new THREE.TextureLoader();\n\t\tloader.crossOrigin = '';\n\t\tloader.load(tourTextureSrc, (texture) => {\n\t\t\t// texture.wrapS = texture.wrapT = THREE.RepeatWrapping;\n\t\t\t// texture.repeat.set(2, 2);\n\t\t\tthis.tourTexture = texture;\n\t\t\tthis.createScene();\n\t\t});\n\t\tthis.body = body;\n\t\tthis.section = section;\n\t\tthis.container = container;\n\t\t// this.shadow = shadow;\n\t\tthis.title = title;\n\t\tthis.abstract = abstract;\n\t\tthis.loader = loader;\n\t}\n\n\tcreateScene() {\n\t\tconst renderer = new THREE.WebGLRenderer({\n\t\t\talpha: true,\n\t\t\tantialias: true\n\t\t});\n\t\trenderer.shadowMap.enabled = true;\n\t\trenderer.setSize(window.innerWidth, window.innerHeight);\n\t\tthis.renderer = renderer;\n\t\t// container.innerHTML = '';\n\t\tthis.container.appendChild(renderer.domElement);\n\n\t\tconst scene = new THREE.Scene();\n\t\tthis.scene = scene;\n\n\t\t/*\n\t\tconst scene = new THREE.Scene();\n\t\tscene.fog = new THREE.FogExp2(0x000000, 0.1); // new THREE.Fog(0x000000, 0, 10);\n\t\tthis.scene = scene;\n\t\t*/\n\n\t\tconst camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1100);\n\t\t// camera.position.set(0, 0, 0);\n\t\tcamera.target = new THREE.Vector3(0, 0, 0);\n\t\tthis.camera = camera;\n\n\t\t/*\n\t\tvar vertex;\n\t\tvar color = new THREE.Color();\n\t\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\n\t\t\tvertex = vertices[ i ];\n\t\t\tvertex.toArray( positions, i * 3 );\n\t\t\tcolor.setHSL( 0.01 + 0.1 * ( i / l ), 1.0, 0.5 );\n\t\t\tcolor.toArray( colors, i * 3 );\n\t\t\tsizes[ i ] = PARTICLE_SIZE * 0.5;\n\t\t}\n\t\t*/\n\n\t\t/*\n\t\tconst positions = new Float32Array(0 * 3);\n\t\tconst colors = new Float32Array(0 * 3);\n\t\tconst sizes = new Float32Array(0);\n\n\t\tconst geometry = new THREE.BufferGeometry();\n\t\tgeometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));\n\t\tgeometry.addAttribute('customColor', new THREE.BufferAttribute(colors, 3));\n\t\tgeometry.addAttribute('size', new THREE.BufferAttribute(sizes, 1));\n\t\tvar material = new THREE.ShaderMaterial({\n\t\t\tuniforms: {\n\t\t\t\tcolor: { value: new THREE.Color(0xffffff) },\n\t\t\t\ttexture: { value: new THREE.TextureLoader().load(\"textures/sprites/disc.png\") }\n\t\t\t},\n\t\t\tvertexShader: document.getElementById('vertexshader').textContent,\n\t\t\tfragmentShader: document.getElementById('fragmentshader').textContent,\n\t\t\talphaTest: 0.9\n\t\t});\n\t\t// const particles = new THREE.Points(geometry, material);\n\t\t*/\n\t\t// const geometry = new THREE.Geometry();\n\t\t/*\n\t\tconst geometry = new THREE.BufferGeometry();\n\t\tconst positions = new Float32Array(0 * 3);\n\t\tgeometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));\n\t\tconst material = new THREE.PointsMaterial({\n\t\t\tsize: 5,\n\t\t\tvertexColors: THREE.VertexColors,\n\t\t\tdepthTest: false,\n\t\t});\n\t\tconst material = new THREE.PointsMaterial({\n\t\t\tsize: 50,\n\t\t\tmap: THREE.ImageUtils.loadTexture(\"http://matthewachase.com/tru-dat-boo.png\"),\n\t\t\tblending: THREE.AdditiveBlending,\n\t\t\ttransparent: true,\n\t\t\tdepthTest: false\n        });\n        const particles = new THREE.Points(geometry, material);\n\t\tscene.add(particles);\n\t\tthis.particles = particles;\n        */\n\n\t\t// const PARTICLE_SIZE = 20;\n\n\t\tconst raycaster = new THREE.Raycaster();\n\t\tthis.raycaster = raycaster;\n\n\t\t/*\n\t\tlet camera;\n\t\tif (USE_ORTHO) {\n\t\t\tconst width = 10;\n\t\t\tconst height = width / this.container.offsetWidth * this.container.offsetHeight;\n\t\t\tcamera = new THREE.OrthographicCamera(-width, width, height, -height, 0.01, 1000);\n\t\t} else {\n\t\t\tcamera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 1000);\n\t\t}\n\t\t// const camera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, 0.01, 1000);\n\t\tcamera.position.set(0, 5.0, 12.0);\n\t\tcamera.up = new THREE.Vector3(0, 0, -1);\n\t\tcamera.lookAt(new THREE.Vector3(0, 0, 0));\n\t\tthis.camera = camera;\n\t\t*/\n\n\t\t/*\n\t\tconst ambient = new THREE.AmbientLight(0x222222);\n\t\tscene.add(ambient);\n\t\tthis.ambient = ambient;\n\t\t*/\n\n\t\t/*\n\t\t// color : Integer, intensity : Float, distance : Number, decay : Float\n\t\tconst light = new THREE.PointLight(0xffffff, 1000, 1000, 1);\n\t\tlight.position.set(0, 0, 0);\n\t\tscene.add(light);\n\t\tthis.light = light;\n\t\t*/\n\n\t\t/*\n\t\tlet light1;\n\t\tlight1 = new THREE.DirectionalLight(0xffffff, 4.0);\n\t\t// light1.castShadow = true;\n\t\t// light1.shadowCameraVisible = true;\n\t\t// light1.mapSize.width = 2048;\n\t\t// light1.mapSize.height = 2048;\n\t\tscene.add(light1);\n\t\tthis.light1 = light1;\n\t\tif (SHOW_HELPERS) {\n\t\t\tconst light1Helper = new THREE.DirectionalLightHelper(light1, 1);\n\t\t\tscene.add(light1Helper);\n\t\t}\n\t\tconst light2 = new THREE.DirectionalLight(0xffffff, 4.0);\n\t\tscene.add(light2);\n\t\tthis.light2 = light2;\n\t\tif (SHOW_HELPERS) {\n\t\t\tconst light2Helper = new THREE.DirectionalLightHelper(light2, 1);\n\t\t\tscene.add(light2Helper);\n\t\t}\n\t\t*/\n\n\t\tconst rotation = new THREE.Euler(0.0, 0.0, 0.0, 'XYZ');\n\t\tconst environment = this.addEnvironment(scene, rotation, this.tourTexture);\n\t\tthis.environment = environment;\n\n\t\tconst pod = this.addPod(scene);\n\t\tthis.pod = pod;\n\n\t\tconst particles = this.addParticles(scene);\n\t\tthis.particles = particles;\n\n\t\t/*\n\t\tconst particleRef = new THREE.Vector3(0.0, 0.0, 1.0);\n\t\tthis.particleRef = particleRef;\n\t\t*/\n\t\t// const shadow = this.addShadow(scene);\n\t\t/*\n\t\tconst tourRotation = new THREE.Euler(0.0, Math.PI * 1.2, 0.0, 'XYZ');\n\t\tconst tourDragRotation = new THREE.Euler(0, 0, 0, 'XYZ');\n\t\tconst tourStartDragRotation = new THREE.Euler(0, 0, 0, 'XYZ');\n\t\tconst tourSpeedRotation = new THREE.Euler(0, 0, 0, 'XYZ');\n\t\tconst tour = this.addVRTour(scene, tourRotation, this.tourTexture);\n\t\tthis.tourRotation = tourRotation;\n\t\tthis.tourDragRotation = tourDragRotation;\n\t\tthis.tourStartDragRotation = tourStartDragRotation;\n\t\tthis.tourSpeedRotation = tourSpeedRotation;\n\t\tthis.tourRotation = tourRotation;\n\t\tthis.tour = tour;\n\t\t*/\n\t\t/*\n\t\tconst particles = addParticles(tour);\n\t\tthis.particles = particles;\n\t\t*/\n\t\t/*\n\t\tconst dragListener = new DragListener(this.container, (e) => {\n\t\t\ttourStartDragRotation.copy(tourDragRotation);\n\t\t}, (e) => {\n\t\t\ttourDragRotation.copy(tourStartDragRotation).add(new THREE.Euler(0, Math.PI * e.strength.x, 0, 'XYZ'));\n\t\t\ttourSpeedRotation.set(0, 0.1, 0, 'XYZ');\n\t\t}, (e) => {\n\t\t\ttourSpeedRotation.set(0, Math.PI * e.speed.x, 0, 'XYZ');\n\t\t});\n\t\tthis.dragListener = dragListener;\n\t\t*/\n\t\tlet lon, lat;\n\t\tconst dragListener = new DragListener(this.container, (event) => {\n\t\t\tlon = this.lon;\n\t\t\tlat = this.lat;\n\t\t}, (event) => {\n\t\t\tthis.lon = -event.distance.x * 0.1 + lon;\n\t\t\tthis.lat = event.distance.y * 0.1 + lat;\n\t\t\tthis.direction = event.distance.x ? (event.distance.x / Math.abs(event.distance.x) * -1) : 1;\n\t\t\tconsole.log('lon', this.lon, 'lat', this.lat, 'direction', this.direction);\n\t\t}, (event) => {\n\t\t\tthis.speed = Math.abs(event.strength.x) * 100;\n\t\t\tconsole.log('speed', this.speed);\n\t\t});\n\t\tthis.dragListener = dragListener;\n\n\t\tthis.onWindowResize = this.onWindowResize.bind(this);\n\t\tthis.onMouseMove = this.onMouseMove.bind(this);\n\t\tthis.onMouseWheel = this.onMouseWheel.bind(this);\n\n\t\tthis.onClick = this.onClick.bind(this);\n\t\twindow.addEventListener('resize', this.onWindowResize, false);\n\t\tdocument.addEventListener('mousemove', this.onMouseMove, false);\n\n\t\tdocument.addEventListener('wheel', this.onMouseWheel, false);\n\t\tthis.container.addEventListener('click', this.onClick, false);\n\t\tthis.section.classList.add('init');\n\t\tthis.play();\n\t\tthis.onWindowResize();\n\t}\n\n\taddEnvironment(parent, rotation, texture) {\n\t\tconst group = new THREE.Group();\n\t\t//\n\t\tvar geometry = new THREE.SphereBufferGeometry(500, 60, 40);\n\t\t// invert the geometry on the x-axis so that all of the faces point inward\n\t\tgeometry.scale(-1, 1, 1);\n\t\tconst material = new THREE.MeshBasicMaterial({\n\t\t\tmap: texture,\n\t\t\t// transparent: true,\n\t\t\t// opacity: 1.0,\n\t\t\tdepthTest: false,\n\t\t});\n\t\t/*\n\t\tconst material = new THREE.MeshStandardMaterial({\n\t\t\tcolor: '#fefefe',\n\t\t\troughness: 0.9,\n\t\t\tmetalness: 0.1,\n\t\t\troughnessMap: texture,\n\t\t\tmap: texture,\n\t\t\ttransparent: true,\n\t\t\topacity: 0,\n\t\t\t// premultipliedAlpha: true,\n\t\t});\n\t\t*/\n\t\tconst sphere = new THREE.Mesh(geometry, material);\n\t\t// sphere.castShadow = false;\n\t\t// sphere.receiveShadow = true;\n\t\tgroup.add(sphere);\n\t\tgroup.sphere = sphere;\n\t\t//\n\t\tgroup.rotation.set(rotation.x, rotation.y, rotation.z);\n\t\tparent.add(group);\n\t\treturn group;\n\t}\n\n\taddPod(parent) {\n\t\tconst geometry = new THREE.PlaneGeometry(300, 300, 3, 3);\n\t\tconst textureLoader = new THREE.TextureLoader();\n\t\tconst texture = textureLoader.load('img/pod.jpg');\n\t\tconst textureAlpha = textureLoader.load('img/pod-alpha.jpg');\n\t\t// assuming you want the texture to repeat in both directions:\n\t\t// texture.wrapS = THREE.RepeatWrapping;\n\t\t// texture.wrapT = THREE.RepeatWrapping;\n\t\t// how many times to repeat in each direction; the default is (1,1),\n\t\t// which is probably why your example wasn't working\n\t\t// texture.repeat.set( 4, 4 );\n\t\tconst material = new THREE.MeshBasicMaterial({\n\t\t\tmap: texture,\n\t\t\talphaMap: textureAlpha,\n\t\t\t// blending: THREE.AdditiveBlending,\n\t\t\t// depthTest: true,\n\t\t\ttransparent: true\n\t\t});\n\t\tconst mesh = new THREE.Mesh(geometry, material);\n\t\t// mesh.material.side = THREE.DoubleSide;\n\t\t// mesh.position.x = 0;\n\t\tmesh.position.y = -300;\n\t\t// rotation.z is rotation around the z-axis, measured in radians (rather than degrees)\n\t\t// Math.PI = 180 degrees, Math.PI / 2 = 90 degrees, etc.\n\t\tmesh.rotation.x = -Math.PI / 2;\n\t\tparent.add(mesh);\n\t\treturn mesh;\n\t}\n\n\taddParticles(parent) {\n\t\tconst geometry = new THREE.BufferGeometry();\n\t\tconst vertices = [];\n\t\tconst textureLoader = new THREE.TextureLoader();\n\t\tconst sprite1 = textureLoader.load('img/pin.png');\n\t\t// hack fix\n\t\tvertices.push(0, -10000, 0);\n\t\tvertices.push(0, 10000, 0);\n\t\t// hack fix\n\t\tgeometry.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n\t\tconst material = new THREE.PointsMaterial({\n\t\t\tsize: 20,\n\t\t\tmap: sprite1,\n\t\t\tblending: THREE.AdditiveBlending,\n\t\t\tdepthTest: false,\n\t\t\ttransparent: false\n\t\t});\n\t\t// materials[i].color.setHSL(1, 0, 0);\n\t\tconst particles = new THREE.Points(geometry, material);\n\t\tparent.add(particles);\n\t\tparticles.vertices = vertices;\n\t\treturn particles;\n\t}\n\n\tenter() {\n\t\t// this.tourCubesAppearAnimation();\n\t}\n\n\ttourCubesAppearAnimation(factor, duration, delay) {\n\t\tconst cubes = this.tour.cubes;\n\t\tfactor = factor || 1.5;\n\t\tduration = duration || 1.4;\n\t\tdelay = delay || 0.01;\n\t\tcubes.forEach((cube, i) => {\n\t\t\tconst position = cube.position_;\n\t\t\tcube.position.set(position.x * factor, position.y * factor, position.z * factor);\n\t\t\tTweenMax.to(cube.position, duration, {\n\t\t\t\tx: position.x,\n\t\t\t\ty: position.y,\n\t\t\t\tz: position.z,\n\t\t\t\tdelay: i * delay,\n\t\t\t\tease: Elastic.easeOut,\n\t\t\t});\n\t\t\tTweenMax.to(cube.material, duration * 0.2, {\n\t\t\t\topacity: 1,\n\t\t\t\tdelay: i * delay,\n\t\t\t\tease: Sine.easeInOut,\n\t\t\t});\n\t\t});\n\t\tsetTimeout(() => {\n\t\t\tthis.randomRotateVRTourRows(this.tour.rows);\n\t\t\tTweenMax.set(this.title, { transform: 'translate3d(0,80px,0)' });\n\t\t\tTweenMax.to(this.title, 0.4, {\n\t\t\t\ttransform: 'translate3d(0,0,0)',\n\t\t\t\topacity: 1,\n\t\t\t\tdelay: 1,\n\t\t\t\tease: Sine.easeInOut,\n\t\t\t});\n\t\t\tTweenMax.set(this.abstract, { transform: 'translate3d(0,80px,0)' });\n\t\t\tTweenMax.to(this.abstract, 0.4, {\n\t\t\t\ttransform: 'translate3d(0,0,0)',\n\t\t\t\topacity: 1,\n\t\t\t\tdelay: 1.2,\n\t\t\t\tease: Sine.easeInOut,\n\t\t\t});\n\t\t}, delay * cubes.length + duration);\n\t}\n\n\ttourCubesWaveAnimation(cubes, factor, duration, delay) {\n\t\tfactor = factor || 1.5;\n\t\tduration = duration || 1.4;\n\t\tdelay = delay || 0.01;\n\t\tcubes.forEach((cube, i) => {\n\t\t\tconst position = cube.position_;\n\t\t\tTweenMax.to(cube.position, 0.3, {\n\t\t\t\tx: position.x * factor,\n\t\t\t\ty: position.y * factor,\n\t\t\t\tz: position.z * factor,\n\t\t\t\tdelay: i * delay,\n\t\t\t\tease: Sine.easeOut,\n\t\t\t\tonComplete: () => {\n\t\t\t\t\tTweenMax.to(cube.position, duration, {\n\t\t\t\t\t\tx: position.x,\n\t\t\t\t\t\ty: position.y,\n\t\t\t\t\t\tz: position.z,\n\t\t\t\t\t\tease: Elastic.easeOut,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\trandomRotateVRTourRows(rows) {\n\t\t// console.log(rows);\n\t\tconst dir = Math.random() > 0.5 ? 1 : -1;\n\t\tconst row = rows[Math.floor(Math.random() * rows.length)];\n\t\tconst rotation = row.rotation;\n\t\tTweenMax.to(rotation, 0.5, {\n\t\t\ty: rotation.y + dir * Math.PI / 2,\n\t\t\tdelay: 1,\n\t\t\tease: Sine.easeInOut,\n\t\t\tonComplete: () => {\n\t\t\t\tthis.randomRotateVRTourRows(rows);\n\t\t\t}\n\t\t});\n\t}\n\n\tonMouseMove(event) {\n\t\tconst w2 = this.container.offsetWidth / 2;\n\t\tconst h2 = this.container.offsetHeight / 2;\n\t\tthis.mouse = {\n\t\t\tx: (event.clientX - w2) / w2,\n\t\t\ty: -(event.clientY - h2) / h2,\n\t\t};\n\t\t// console.log('onMouseMove', this.mouse);\n\n\t\t/*\n\t\tvar attributes = geometry.attributes;\n\t\traycaster.setFromCamera( mouse, camera );\n\t\tintersects = raycaster.intersectObject( particles );\n\t\tif ( intersects.length > 0 ) {\n\t\t\tif ( INTERSECTED != intersects[ 0 ].index ) {\n\t\t\t\tattributes.size.array[ INTERSECTED ] = PARTICLE_SIZE;\n\t\t\t\tINTERSECTED = intersects[ 0 ].index;\n\t\t\t\tattributes.size.array[ INTERSECTED ] = PARTICLE_SIZE * 1.25;\n\t\t\t\tattributes.size.needsUpdate = true;\n\t\t\t}\n\t\t} else if ( INTERSECTED !== null ) {\n\t\t\tattributes.size.array[ INTERSECTED ] = PARTICLE_SIZE;\n\t\t\tattributes.size.needsUpdate = true;\n\t\t\tINTERSECTED = null;\n\t\t}\n\t\t*/\n\t}\n\n\tonClick(event) {\n\t\tif (!event.shiftKey) {\n\t\t\treturn;\n\t\t}\n\t\t// this.tourCubesWaveAnimation(this.tour.cubes);\n\t\tconst raycaster = this.raycaster;\n\t\t// update the picking ray with the camera and mouse position\n\t\traycaster.setFromCamera(this.mouse, this.camera);\n\t\t// calculate objects intersecting the picking ray\n\t\tconst intersections = raycaster.intersectObjects(this.environment.children);\n\t\tif (intersections) {\n\t\t\tintersections.forEach(intersection => {\n\t\t\t\tconsole.log(intersection);\n\t\t\t\tconst particles = this.particles;\n\t\t\t\tconsole.log(this.particles);\n\t\t\t\tconst geometry = particles.geometry;\n\t\t\t\tconst p = intersection.point.clone();\n\t\t\t\t// p.multiplyScalar(1);\n\t\t\t\t/*\n\t\t\t\tconst positions = new Float32Array([...particles.geometry.attributes.position.array, p.x, p.y, p.z]);\n\t\t\t\tconst attribute = new THREE.BufferAttribute(positions, 3);\n\t\t\t\tattribute.dynamic = true;\n\t\t\t\tgeometry.addAttribute('position', attribute);\n\t\t\t\tpositions.needsUpdate = true;\n\t\t\t\tparticles.geometry.setDrawRange(0, positions.length);\n\t\t\t\tparticles.geometry.verticesNeedUpdate = true;\n\t\t\t\tparticles.geometry.elementsNeedUpdate = true;\n\t\t\t\t// particles.geometry.computeVertexNormals();\n                console.log(particles.geometry);\n                */\n\t\t\t\tparticles.vertices.push(p.x, p.y, p.z);\n\t\t\t\tparticles.vertices.needsUpdate = true;\n\t\t\t\tparticles.geometry.addAttribute('position', new THREE.Float32BufferAttribute(particles.vertices, 3));\n\n\t\t\t\t/*\n\t\t\t\tgeometry.vertices.push(p);\n\t\t\t\t// geometry.colors.push(new THREE.Color(Math.random(), Math.random(), Math.random()));\n\t\t\t\tgeometry.verticesNeedUpdate = true;\n\t\t\t\tgeometry.elementsNeedUpdate = true;\n\t\t\t\tgeometry.computeVertexNormals();\n\t\t\t\t*/\n\t\t\t\t// console.log(p);\n\t\t\t});\n\t\t}\n\t\tconsole.log(intersections);\n\t\t/*\n\t\tfor (var i = 0; i < intersects.length; i++ ) {\n\t\t\tconsole.log(intersections[i])\n\t\t\tintersects[i].object.material.color.set( 0xff0000 );\n\t\t}\n\t\t*/\n\t}\n\n\tonWindowResize() {\n\t\tconst container = this.container,\n\t\t\trenderer = this.renderer,\n\t\t\tcamera = this.camera;\n\t\tconst size = this.size;\n\t\tsize.width = container.offsetWidth;\n\t\tsize.height = container.offsetHeight;\n\t\tsize.aspect = size.width / size.height;\n\t\tif (renderer) {\n\t\t\trenderer.setSize(size.width, size.height);\n\t\t}\n\t\tif (camera) {\n\t\t\tcamera.aspect = size.width / size.height;\n\t\t\tcamera.updateProjectionMatrix();\n\t\t}\n\t}\n\n\tonMouseWheel(event) {\n\t\tconst camera = this.camera;\n\t\tconst fov = camera.fov + event.deltaY * 0.01;\n\t\tcamera.fov = THREE.Math.clamp(fov, 30, 75);\n\t\tcamera.updateProjectionMatrix();\n\t}\n\n\tdoParallax() {\n\t\t// parallax\n\t\tconst parallax = this.parallax;\n\t\tparallax.x += (this.mouse.x - parallax.x) / 8;\n\t\tparallax.y += (this.mouse.y - parallax.y) / 8;\n\t\t// this.light1.position.set(parallax.x * 5.0, 6.0 + parallax.y * 2.0, 4.0);\n\t\t// this.light2.position.set(parallax.x * -5.0, -6.0 - parallax.y * 2.0, 4.0);\n\t\t/*\n\t\tconst size = this.size;\n\t\tconst sx = size.width < 1024 ? 0 : -3;\n\t\tconst sy = size.width < 1024 ? -2 : 0;\n\t\tthis.tour.position.x = sx + parallax.x * 0.2;\n\t\tthis.tour.position.y = sy + parallax.y * 0.2;\n\t\t*/\n\t\t//\n\t\t/*\n\t\tconst titleXy = {\n\t\t\tx: -50 + 0.5 * -parallax.x,\n\t\t\ty: -50 + 0.5 * -parallax.y,\n\t\t};\n\t\tTweenMax.set(this.title, {\n\t\t\ttransform: 'translateX(' + titleXy.x + '%) translateY(' + titleXy.y + '%)'\n\t\t});\n\t\t*/\n\t\t/*\n\t\tconst shadowXy = {\n\t\t\tx: -50 + 3 * -parallax.x,\n\t\t\ty: -50 + 3 * -parallax.y,\n\t\t};\n\t\tTweenMax.set(this.shadow, {\n\t\t\ttransform: 'translateX(' + shadowXy.x + '%) translateY(' + shadowXy.y + '%)'\n\t\t});\n\t\t*/\n\t}\n\n\trender(delta) {\n\t\t/*\n\t\tif (!this.dragListener.dragging) {\n\t\t\tthis.tourRotation.y += this.tourSpeedRotation.y;\n\t\t\tthis.tourSpeedRotation.y += (0.002 - this.tourSpeedRotation.y) / 50;\n\t\t}\n\t\tthis.tour.rotation.copy(this.tourRotation).add(this.tourDragRotation);\n\t\t*/\n\t\t/*\n\t\tthis.particles.geometry.vertices.forEach((vertex, i) => {\n\t\t\tconst local = this.tour.localToWorld(vertex.clone());\n\t\t\tconst distance = local.distanceTo(this.particleRef);\n\t\t\tconst s = Math.max(0, Math.min(1, (1 - distance))) * 5;\n\t\t\tthis.particles.geometry.colors[i] = new THREE.Color(s, s, s);\n\t\t\tthis.particles.geometry.colorsNeedUpdate = true;\n\t\t});\n\t\t*/\n\t\tthis.updateCamera();\n\t\tthis.renderer.render(this.scene, this.camera);\n\t\tthis.doParallax();\n\t}\n\n\tupdateCamera() {\n\t\tconst camera = this.camera;\n\t\tconst direction = this.direction;\n\t\tlet speed = this.speed;\n\t\tlet lat = this.lat;\n\t\tlet lon = this.lon;\n\t\tlet phi = this.phi;\n\t\tlet theta = this.theta;\n\t\tif (this.dragListener.dragging === false) {\n\t\t\tlon += 0.01 * direction * speed;\n\t\t\tspeed = Math.max(1, speed * 0.98);\n\t\t}\n\t\tlat = Math.max(-85, Math.min(85, lat));\n\t\tphi = THREE.Math.degToRad(90 - lat);\n\t\ttheta = THREE.Math.degToRad(lon);\n\t\tcamera.target.x = 500 * Math.sin(phi) * Math.cos(theta);\n\t\tcamera.target.y = 500 * Math.cos(phi);\n\t\tcamera.target.z = 500 * Math.sin(phi) * Math.sin(theta);\n\t\tcamera.lookAt(camera.target);\n\t\tthis.lat = lat;\n\t\tthis.lon = lon;\n\t\tthis.phi = phi;\n\t\tthis.theta = theta;\n\t\tthis.speed = speed;\n\t\t/*\n\t\t// distortion\n\t\tcamera.position.copy( camera.target ).negate();\n\t\t*/\n\t}\n\n\tplay() {\n\t\tconst clock = new THREE.Clock();\n\t\tconst loop = (time) => {\n\t\t\tconst delta = clock.getDelta();\n\t\t\tthis.render(delta);\n\t\t\twindow.requestAnimationFrame(loop);\n\t\t};\n\t\tloop();\n\t}\n\n}\n\nvar tour = new VRTour();\n\nwindow.onload = () => {\n\ttour.init();\n\tsetTimeout(() => {\n\t\tconsole.log(tour.tour);\n\t\ttour.enter();\n\t}, 1000);\n};\n"],"file":"docs/js/vrtour.js"}